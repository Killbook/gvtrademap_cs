/*-------------------------------------------------------------------------

 緯度、経度描画
 ゲームの仕様上
 GAME_WIDTH		= 16384;
 GAME_HEIGHT	= 8192;
 を使用する
 100毎に線が引かれる

---------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------
 using
---------------------------------------------------------------------------*/
using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.DirectX;
using System.Drawing;

using directx;

/*-------------------------------------------------------------------------

---------------------------------------------------------------------------*/
namespace gvtrademap_cs
{
	/*-------------------------------------------------------------------------

	---------------------------------------------------------------------------*/
	static class latitude_longitude
	{
		/*-------------------------------------------------------------------------
		 線描画
		 1000刻みでの線となる
		---------------------------------------------------------------------------*/
		static public void DrawLines(gvt_lib lib)
		{
			lib.loop_image.EnumDrawCallBack(new LoopXImage.DrawHandler(draw_lines_proc), 0);

			// 縦方向は1回の描画でよい
			LoopXImage	image	= lib.loop_image;
			Vector2		size	= image.Device.client_size;
			Vector2	offset = image.GetDrawOffset();

			int index	= 0;
			for(float y=0; y<def.GAME_HEIGHT; y+=1000, index++){
				// 地図座標に変換
				Vector2	pos0	= transform.game_pos2_map_pos(new Vector2(0, y), image);
				Vector2 pos		= image.GlobalPos2LocalPos(pos0, offset);

				if(pos.Y < 0)		continue;
				if(pos.Y >= size.Y)	continue;

				image.Device.DrawLine(new Vector3(0, pos.Y, 0.79f), new Vector2(size.X, pos.Y), Color.FromArgb(128, 0, 0, 0).ToArgb());
			}
		}

		/*-------------------------------------------------------------------------
		 線描画
		---------------------------------------------------------------------------*/
		static private void draw_lines_proc(Vector2 offset, LoopXImage image)
		{
			Vector2		size	= image.Device.client_size;
	
			int			index	= 0;
			for(float x=0; x<def.GAME_WIDTH; x+=1000, index++){
				// 地図座標に変換
				Vector2	pos0	= transform.game_pos2_map_pos(new Vector2(x, 0), image);
				Vector2 pos		= image.GlobalPos2LocalPos(pos0, offset);

				if(pos.X < 0)		continue;
				if(pos.X >= size.X)	continue;

				image.Device.DrawLine(new Vector3(pos.X, 0, 0.79f), new Vector2(pos.X, size.Y), Color.FromArgb(128, 0, 0, 0).ToArgb());
			}
		}
	
		/*-------------------------------------------------------------------------
		 線描画
		 100刻みでの線となる
		---------------------------------------------------------------------------*/
		static public void DrawLines100(gvt_lib lib)
		{
			lib.loop_image.EnumDrawCallBack(new LoopXImage.DrawHandler(draw_lines100_proc), 0);

			// 縦方向は1回の描画でよい
			LoopXImage	image	= lib.loop_image;
			Vector2		size	= image.Device.client_size;
			Vector2	offset = image.GetDrawOffset();

			int index	= 0;
			for(float y=0; y<def.GAME_HEIGHT; y+=100, index++){
				// 地図座標に変換
				Vector2	pos0	= transform.game_pos2_map_pos(new Vector2(0, y), image);
				Vector2 pos		= image.GlobalPos2LocalPos(pos0, offset);

				if(index >= 10)	index	= 0;

				if(pos.Y < 0)		continue;
				if(pos.Y >= size.Y)	continue;

				int		color	= (index == 0)? Color.FromArgb(128, 0, 0, 0).ToArgb(): Color.FromArgb(128, 128, 128, 128).ToArgb();
				image.Device.DrawLine(new Vector3(0, pos.Y, 0.79f), new Vector2(size.X, pos.Y), color);
			}
		}

		/*-------------------------------------------------------------------------
		 線描画
		---------------------------------------------------------------------------*/
		static private void draw_lines100_proc(Vector2 offset, LoopXImage image)
		{
			Vector2		size	= image.Device.client_size;
	
			int			index	= 0;
			for(float x=0; x<def.GAME_WIDTH; x+=100, index++){
				// 地図座標に変換
				Vector2	pos0	= transform.game_pos2_map_pos(new Vector2(x, 0), image);
				Vector2 pos		= image.GlobalPos2LocalPos(pos0, offset);

				if(index >= 10)	index	= 0;

				if(pos.X < 0)		continue;
				if(pos.X >= size.X)	continue;

				int		color	= (index == 0)? Color.FromArgb(128, 0, 0, 0).ToArgb(): Color.FromArgb(128, 128, 128, 128).ToArgb();
				image.Device.DrawLine(new Vector3(pos.X, 0, 0.79f), new Vector2(pos.X, size.Y), color);
			}
		}

		/*-------------------------------------------------------------------------
		 緯度、経度描画
		 画面の上と右に描画される
		---------------------------------------------------------------------------*/
		static public void DrawPoints(gvt_lib lib)
		{
			d3d_systemfont	font	= lib.device.systemfont;

			font.Begin();
			lib.device.device.RenderState.ZBufferEnable		= false;
			lib.loop_image.EnumDrawCallBack(new LoopXImage.DrawHandler(draw_points_proc), 0);

			// 縦方向は1回の描画でよい	
			Vector2		size	= lib.loop_image.Device.client_size;
			Vector2	offset = lib.loop_image.GetDrawOffset();
			for(float y=0; y<def.GAME_HEIGHT; y+=1000){
				Vector2	pos0	= transform.game_pos2_map_pos(new Vector2(0, y), lib.loop_image);
				Vector2 pos		= lib.loop_image.GlobalPos2LocalPos(pos0, offset);

				Rectangle		rect	= font.MeasureText(y.ToString());

				pos.Y	-= 5;
				if(pos.Y + (rect.Height+4) < 0)	continue;
				if(pos.Y >= size.Y)				continue;

				lib.device.DrawFillRect(new Vector3(size.X - (rect.Width) - 2, pos.Y-1, 0.1f), new Vector2(rect.Width + 2*2, rect.Height), Color.FromArgb(220, 100, 100, 100).ToArgb());
				font.DrawTextR(y.ToString(), (int)size.X, (int)pos.Y, Color.White);
			}
			font.End();
			lib.device.device.RenderState.ZBufferEnable		= true;
		}

		/*-------------------------------------------------------------------------
		 緯度、経度描画
		---------------------------------------------------------------------------*/
		static private void draw_points_proc(Vector2 offset, LoopXImage image)
		{
			d3d_systemfont	font	= image.Device.systemfont;
			Vector2			size	= image.Device.client_size;

			for(float x=0; x<def.GAME_WIDTH; x+=1000){
				Vector2	pos0	= transform.game_pos2_map_pos(new Vector2(x, 0), image);
				Vector2 pos		= image.GlobalPos2LocalPos(pos0, offset);

				Rectangle		rect	= font.MeasureText(x.ToString());

				if(pos.X + (rect.Width+4) < 0)	continue;
				if(pos.X >= size.X)				continue;
				
				image.Device.DrawFillRect(new Vector3(pos.X - (rect.Width/2) - 3, 0, 0.1f), new Vector2(rect.Width + 2*2, rect.Height), Color.FromArgb(220, 100, 100, 100).ToArgb());
				font.DrawTextC(x.ToString(), (int)pos.X, 0, Color.White);
			}
		}
	}
}
